<html>
	<head>
		<title>Get Me Out</title>

		<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script> -->
		<script src="javascript/three.min.js"></script>
		<script src="javascript/THREEx.KeyboardState.js"></script>
		<script src="javascript/collision.js"></script>
		<!-- <script src="javascript/physijs/physi.js"></script> -->
		<!-- <script src="javascript/OrbitControls.js"></script> -->

		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="javascript/maze.js"></script>

		<script>
			var scene, scene2;
			var camera, camera2;
			var renderer;
			var directionallight;
			var keyboard;

			var cube, cube_material, cube_mesh;
			var help_cube, help_cube_mesh;
			var PlaneGeometry, material, plane;

			var collidable_wall_mesh;
			var hit = false;

			var raycaster;
			var raycasters = [];
			var position;

			var rays = [

				new THREE.Vector3(0, 1, 0),	// forward
				new THREE.Vector3(0, -1, 0), // backward
				new THREE.Vector3(-1, 0, 0),	// left
				new THREE.Vector3(1, 0, 0),	// right
				new THREE.Vector3(1, 1, 0),	// forward right
				new THREE.Vector3(-1, 1, 0),	// forward left
				new THREE.Vector3(1, -1, 0), // backward right
				new THREE.Vector3(-1, -1, 0) // backward left

			];

			var arrowhelpers = [];
			var groupArrowHelper = new THREE.Object3D();

			start = function(){

				scene = new THREE.Scene();
				scene2 = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
				camera2 = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );

				keyboard = new THREEx.KeyboardState();

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0xffffff);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				document.body.appendChild( renderer.domElement );

				// player object
				cube = new THREE.BoxGeometry(1,1,1);
				cube_material = new THREE.MeshBasicMaterial({color: 0x00a000});
				cube_mesh = new THREE.Mesh(cube, cube_material);
				cube_mesh.position.set(-45, -51, 0.6);
				scene.add(cube_mesh);

				help_cube = new THREE.CylinderGeometry(0, 3, 10, 4, 1, true);
				help_cube_mesh = new THREE.Mesh(help_cube, new THREE.MeshBasicMaterial({color: 0xee0000}));
				help_cube_mesh.position.set(cube_mesh.position.x, cube_mesh.position.y, cube_mesh.position.z);
				scene2.add(help_cube_mesh);

				directionallight = new THREE.DirectionalLight(0xffffff, 1);
				directionallight.position.set(0, 0, 100);
				directionallight.target.position = scene.position;
				scene.add(directionallight);

				PlaneGeometry = new THREE.PlaneGeometry(200, 150, 1);
				material = new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader().load("assets/ground.jpg") });
				plane = new THREE.Mesh(PlaneGeometry, material);
				scene.add(plane);

				camera.position.set(scene.position.x, scene.position.y - 3, scene.position.z + 1 );
				camera2.position.set(scene.position.x, scene.position.y, scene.position.z + 200);
				camera.lookAt(scene.position);

				scene.add(camera);
				cube_mesh.add(camera);

				// initializing maze
				setup();
				draw_maze();


				position = new THREE.Vector3(cube_mesh.position.x, cube_mesh.position.y, cube_mesh.position.z);
				// arrowhelper = new THREE.ArrowHelper(rays[2], position, 2);
				// scene.add(arrowhelper);

				// groupArrowHelper.position.set(position);

				for ( var i = 0; i < rays.length; i++){
					arrowhelper = new THREE.ArrowHelper(rays[i].normalize(), groupArrowHelper.position);
					arrowhelpers.push(arrowhelper);
					// scene.add(arrowhelper);
					groupArrowHelper.add(arrowhelper);
				}

				// groupArrowHelper.position = cube_mesh.position;
				groupArrowHelper.position.y = cube_mesh.position.y;
				groupArrowHelper.position.x = cube_mesh.position.x;
				groupArrowHelper.position.z = 0.6;

				console.log(cube_mesh.position.z);

				cube_mesh.add(groupArrowHelper);

				// groupArrowHelper.add(arrowhelpers);
				scene.add(groupArrowHelper);
				// scene2.add(groupArrowHelper.clone());

				console.log(arrowhelpers);

				raycaster = new THREE.Raycaster();
				// loop for detecting the collision
				// for ( var i = 0; i < rays.length; i++ ){
				//
				// 	var direction = position.sub(rays[i]);
				// 	raycaster.set(position, rays[i], 1.5, 1.9);
				//
				// 	raycasters.push(raycaster);
				//
				// }

			}

			// required for rendering the objects
			var render = function () {

				requestAnimationFrame( render );
				renderer.clear();
				renderer.render(scene, camera);
				renderer.clearDepth();
				renderer.render(scene2, camera2);

				update();

			};

			var arrow;

			var update = function(){

				groupArrowHelper.position.set(cube_mesh.position.x, cube_mesh.position.y, cube_mesh.position.z);
				// groupArrowHelper.rotation.z += Math.PI / 180

				detectCollision();

				// 0 = forward
				// 1 = backward
				// 2 = left
				// 3 = right
				// 4 = forward right
				// 5 = forward left
				// 6 = backward right
				// 7 = backward left

				// help_cube_mesh.position.set(cube_mesh.position);

				// keyboard controls
				if (keyboard.pressed("W") || keyboard.pressed("up")){
					cube_mesh.translateY( 0.1 );
					if (hit === false){
						help_cube_mesh.translateY( 0.1 );
					}
				}
				if (keyboard.pressed("A") || keyboard.pressed("left")){
					cube_mesh.rotation.z += 1 * Math.PI / 180;
					help_cube_mesh.rotation.z += 1 * Math.PI / 180;
				}
				if (keyboard.pressed("S") || keyboard.pressed("down")){
					cube_mesh.translateY( -0.1 );
					if (hit === false){
						help_cube_mesh.translateY( -0.1 );
					}
				}
				if (keyboard.pressed("D") || keyboard.pressed("right")){
					cube_mesh.rotation.z -= 1 * Math.PI/180;
					help_cube_mesh.rotation.z -= 1 * Math.PI/180;
				}

			}

			// initializing the component's for scene
			start();

			var c = get_collidable_walls();
			console.log(c);

			render();
		</script>
	</body>
</html>
